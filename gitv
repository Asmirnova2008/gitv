#!/usr/bin/lua
package.path = package.path .. ";"..os.getenv('HOME').."/bin/?.lua"
require("mylib")
 
-- order doesn't matter
g_etagsSrc={ "%.c$", "%.cpp$", "%.h$","%.hpp$", "%.inl$", "%.py$", "%.lua$"}
g_vimSrc={"%.wiki$","%.wrl$", "%.lua$","%.py$", "%.c$", "%.h$", "%.hpp$", "%.txt$", "%.inl$", "%.cpp$"}
g_grepSrc=g_etagsSrc
g_cache_folder='/tmp/'
g_vimpath='vim'
g_gvimpath='gvim'
g_commitIgnorePattern={'^$','ogreconfig.txt', 'ogreconfig_linux.txt', 'debug_plot%.', 'OgreFltkConsole.exe', 'console.xml', 'OgreFltkConsoleJIT.exe','optimizelog'}

function printHelp()
	print([[
Usage: gitv <command> [option] [<args>]

The most commonly used gitv commands are:
  --help       Show this page.
  vi         Open a file in the git repository whose name contains 
             the keyword using vim. When no keyword is given, history will be shown.
               $ gitv vi [option] keyword
             or
               $ gitv vi [option]
             option -l: search only subdirectories of the current directory.
  gvim       Open a file using gvim
  gedit      Open a file using gedit
  choose     Write choosen file name to /tmp/chosen
               $ gitv choose keyword
  clear-hist Clear history
  sync       Commit, pull, and then push. 
  sync .	 Commit only the current folder (without recursing), pull, and then push.
  pull       Pull the current branch from all remotes
  fetch      Fetch the current branch from all remotes
  push       Push the current branch to all remotes
  commit     Interactively commit the current branch. gitv ci also works.
  find       Find files 
               $ gitv find keyword
  grep       Unlike git grep, entire repository (not limited to the current 
             directory) will be searched. Files with allowed extensions will only
             be searched. (see ~/bin/gitv.) Lua patterns are used.
               $ gitv grep keyword
  etags .    Generate TAGS for all tracked files in the current folder recursively
               $ gitv etags .
  etags      Generate TAGS for all tracked files in the git repository
  diff       Show differences between commits. 
               $ gitv diff
               $ gitv diff HEAD~10
  ]])
end

if os.isWindows() then
	if os.isFileExist("c:\\Program Files\\Git\\share\\vim\\vim73\\vim.exe") then
		g_vimpath='""c:\\Program Files\\Git\\share\\vim\\vim73\\vim.exe"'
		g_gvimpath='"c:\\Program\ Files\\Git\\share\\vim\\vim73\\gvim.exe"'
	else
		g_vimpath='c:\\msysgit\\msysgit\\share\\vim\\vim73\\vim'
		g_gvimpath='c:\\msysgit\\msysgit\\share\\vim\\vim73\\gvim'
	end
	g_cache_folder=os.home_path() ..'/'
end
function git_top()
	return string.lines(os.capture('git rev-parse --show-toplevel', true))[1]
end 
git_tools={}

function git_tools.pull(path)
	if os.isFileExist(path..'/.git/HEAD') then
		local remotes=array.filter(function (a) return string.len(a)>1 end, string.lines(git_tools.capture('cd "'..path..'";git remote',true)))
		if arg[2] then
			remotes=array.filter(function (a) return select(1,string.find(a,arg[2])) end, remotes)
		end
		local curr_branch=array.filter(function (a) return string.sub(a,1,1)=='*' end ,  string.lines(git_tools.capture('cd "'..path..'";git branch',true)))[1]
		curr_branch=string.sub(curr_branch,2)
		for k,v in ipairs(remotes) do

			print(v)
			local cmd='cd "'..path..'";git pull '..v..curr_branch
			print('> '..cmd)
			git_tools.execute(cmd)
		end
	else
		print(path..'/.git/HEAD' .." doesn't exist")
	end
end
function git_tools.fetch(path)
	if os.isFileExist(path..'/.git/HEAD') then
		local remotes=array.filter(function (a) return string.len(a)>1 end, string.lines(git_tools.capture('cd "'..path..'";git remote',true)))
		if arg[2] then
			remotes=array.filter(function (a) return select(1,string.find(a,arg[2])) end, remotes)
		end
		local curr_branch=array.filter(function (a) return string.sub(a,1,1)=='*' end ,  string.lines(git_tools.capture('cd "'..path..'";git branch',true)))[1]
		curr_branch=string.sub(curr_branch,2)
		for k,v in ipairs(remotes) do

			print(v)
			local cmd='cd "'..path..'";git fetch '..v..curr_branch
			print('> '..cmd)
			git_tools.execute(cmd)
		end
	end
end
function git_tools.tokenize_cmd(cmd)
	local tokens=string.tokenize(cmd, ';')
	for i=1,#tokens do
		if string.sub(tokens[i],1,3)=="cd " then
			tokens[i]=string.gsub(tokens[i], '/','\\')
		end
	end
	return tokens
end
function git_tools.capture(cmd, isRaw)
	if os.isWindows() then
		local tokens=git_tools.tokenize_cmd(cmd)
		os.createBatchFile('_temp.bat', tokens, true)
		return os.capture('_temp.bat', isRaw)	
	else
		return os.capture(cmd, isRaw)
	end
end
function git_tools.execute(cmd)
	if os.isWindows() then
		local tokens=git_tools.tokenize_cmd(cmd)
		os.createBatchFile('_temp.bat', tokens, true)
		--os.execute('type _temp.bat')
		return os.execute('_temp.bat')	
	else
		return os.execute(cmd)
	end
end
function git_tools.getUntracked(path)
	-- git-svn or git is used as opposed to the plain svn
	local status= string.lines(git_tools.capture('cd "'..path..'";git status -s .', true))
	--print('stat=',status[2])
	local untracked={}
	for il, line in ipairs(status) do
		local s,e,c=string.find(line, "%?%? (.+)")
		if s then
			untracked[#untracked+1]=c
		end
	end
	return untracked
end
function git_tools.getFilesToCommit(path)
		status= string.lines( git_tools.capture('cd "'..path..'";git status .', true))
		local modified={}
		for il, line in ipairs(status) do
			local s,e,c=string.find(line, '#%s+modified:%s+(.+)')
			if not c then
				s,e,c=string.find(line, '#%s+new file:%s+(.+)')
			end
			if not c then
				s,e,c=string.find(line, '#%s+renamed:%s+(.+)')
			end
			if c then 
				if not string.isMatched(os.filename(c), g_commitIgnorePattern) then
					modified[#modified+1]=c
				end
			end
		end
		return modified
end
function git_tools.commit(path,force)
	if os.isFileExist(path..'/.git/HEAD') then
		local untracked=git_tools.getUntracked(path)
		if #untracked>=1 then
			print('Untracked files:')
			for i,v in ipairs(untracked) do print(v) end
			print('Do you want to add these untracked files to git repository? (YES/edit/[no])')
			local cmd=''
			for i, v in ipairs(untracked) do 
				cmd=cmd.. 'git add "'..v..'"\n'
			end
			local ioread
			if force then
				ioread='no'
			else
				ioread=io.read('*line')
			end
			if string.sub(ioread,1,3)=="YES" then
				os.execute2('cd "'..path..'"', cmd)
				print('\n Added '..#untracked..' files')
			elseif string.sub(ioread,1,4)=="edit" then
				os.createBatchFile("gitscript.bat", {'cd "'..path..'"',cmd})
				os.execute2('vim gitscript.bat')
				if os.isUnix() then
					os.execute2('sh gitscript.bat')
				else
					os.execute('gitscript')
				end
			else
				print('\n ignoring all untracked files')
			end
			print('\n\n-----------------------')
		end
		local modified=git_tools.getFilesToCommit(path)
		if #modified>=1 then
			printTable(modified)
			local bDone
			repeat
				bDone=true
				print('Do you want to commit these files to git repository? (yes/[no]/diff optionally followed by a commit message)')
				local ioread
				if force then
					ioread='yes'..table.concat(array.sub(arg, 2), " ")
				else
					ioread=io.read('*line')
				end
				if string.sub(ioread,1,3)=="yes" or string.sub(ioread,1,1)=='y' then
					local msg=string.sub(ioread,4)
					if msg=='' then
						msg='(no msg)'
					end
					for im, m in ipairs(modified) do
						git_tools.execute('cd "'..path..'";git add "'..m..'"')
					end
					git_tools.execute('cd "'..path..'";git commit -m "'..msg..'"')
					if path~="n" then
						if useGitSVN then
							print('Do you want to commit these files to SVN server? (yes/no)')
							local ioread=io.read('*line')
							if string.sub(ioread,1,3)=='yes' then
								os.execute('cd "'..path..'";git svn dcommit')
							end
						end
					end
					print('\n\n-----------------------')

					for im, m in ipairs(modified) do
						print('"'..m..'" added')
					end
					git_tools.execute('cd "'..path..'";git status . -s')
				elseif string.sub(ioread,1,1)=="d" then
					git_tools.execute('cd "'..path..'";git diff')
					bDone=false
				end 
			until bDone
		else
			print('No locally modified files\n')
			git_tools.execute('cd "'..path..'";git status . -s')
			if useGitSVN then
				os.execute('cd "'..path..'";git diff refs/remotes/git-svn')
				print('Do you want to commit to SVN server? (yes/no)')
				local ioread=io.read('*line')
				if string.sub(ioread,1,3)=='yes' then
					os.execute('cd "'..path..'";git svn dcommit')
				end
			end
		end
	end
end
function git_tools.push(path)
	if os.isFileExist(path..'/.git/HEAD') then
		local remotes=array.filter(function (a) return string.len(a)>1 end, string.lines(git_tools.capture('cd "'..path..'";git remote',true)))
		if arg[2] then
			remotes=array.filter(function (a) return select(1,string.find(a,arg[2])) end, remotes)
		end
		local curr_branch=array.filter(function (a) return string.sub(a,1,1)=='*' end ,  string.lines(git_tools.capture('cd "'..path..'";git branch',true)))[1]
		curr_branch=string.sub(curr_branch,2)
		for k,v in ipairs(remotes) do
			local cmd='cd "'..path..'";git push '..v..curr_branch
			print('> '..cmd)
			git_tools.execute(cmd)
		end
	end
end

function getHashTbl(list, conversionFcn)
	if conversionFcn==nil then
		conversionFcn=function (v) return v end
	end

	local hcache={}
	for i,v in ipairs(list) do
		hcache[conversionFcn(v)]=true
	end
	return hcache
end
function interactiveChoose(fn, fromHistory)
	local index=1
	local function loadHistory(currDir)
		local hcache={_list={}}
		local history={}
		if os.isFileExist(g_cache_folder..'cache_hist.txt') then
			history= table.fromstring(util.readFile(g_cache_folder..'cache_hist.txt'))
			hcache=getHashTbl(history, 
			function (v) 
				v[1]=os.absoluteToRelativePath(v[1], currDir)
				return v[1]
			end
			)
			local fncache=getHashTbl(fn, 
			function (v)
				return v[1]
			end
			)
				
			hcache._list={}
			for i,v in ipairs(history) do
				if fncache[v[1]] then
					hcache._list[#hcache._list+1]=v
				end
			end
		end
		return history, hcache
	end
	local currDir=os.currentDirectory()
	local history, hcache=loadHistory(currDir)
	if #fn==0 then
		print('Choose from History:')
		fn=history
		hcache._list=fn
	end
	-- reorder fn based on history
	local nhist=#hcache._list
	do
		local fn2={}
		local c=1
		for i,v in ipairs(hcache._list) do
			fn2[#fn2+1]=v
		end
		for i,v in ipairs(fn) do
			if not hcache[v[1]] then 
				fn2[#fn2+1]=v
			end
		end
		fn=fn2
	end

	while #fn>1 do
		-- start file choose interface
		print('--------------------------------------------------------------')
		local c=1
		for i,v in ipairs(fn) do
			if c==1 and c<=nhist then
				print(v[1], "("..tostring(c).." - default)") 
			else
				print(v[1], "("..tostring(c)..")") 
			end
			if c==nhist then
				print('--------------------------------------------------------------')
			end
			c=c+1
			if c>20 then
				print('... not displaying more candidates') 
				break
			end
		end
		print('Enter file shortcut (shown on the right) or keyword to further refine the search:')
		local cmd=io.read('*line')
		index=tonumber(cmd) 

		if cmd=="" then 
			if fromHistory or nhist~=0 then
				index=1
				break
			else
				return nil 
			end
		elseif index==nil then 
			-- refine search
			local refinedFn={}
			for i,v in ipairs(fn) do
				local idx=string.findLastOf(string.upper(v[1]), string.upper(cmd))
				if idx~=nil then
					array.pushBack(refinedFn, v)
				end
			end
			fn=refinedFn
			index=1
			if #fn==0 then return nil end
		else
			break
		end
	end
	do -- add to history
		if #fn==0 then return nil end
		if fn[index]==nil then return nil end
		local chosenFile=fn[index][1]
		if not history then history=loadHistory() end
		local max_num_hist=10
		history=array.filter(function (x) return x[1]~=chosenFile end, history)
		history={{chosenFile}, unpack(history)}
		for i =1, #history do
			history[i]={os.relativeToAbsolutePath(history[i][1], currDir)}
		end
		history[max_num_hist+1]=nil
		util.writeFile(g_cache_folder..'cache_hist.txt', table.tostring(history))
	end

	return fn[index]
end
function findFileFromGit(key, ...)
	local fn
	do
		local str=os.capture('git ls-files ../..', true)
		local files=string.lines(str)
		fn={}
		local keys={key,...}
		for ifile, file in ipairs(files) do
			if select(1,string.find(file, "%.lua$")) 
				or select(1,string.find(file, "%.c$")) 
				or select(1,string.find(file, "%.h$")) 
				or select(1,string.find(file, "%.hpp$")) 
				or select(1,string.find(file, "%.txt$")) 
				or select(1,string.find(file, "%.inl$")) 
				or select(1,string.find(file, "%.cpp$")) then
				for ikey,key in ipairs(keys) do
					if select(1,string.find(string.upper(file), string.upper(key))) then
						fn[#fn+1]={file}
						break
					end
				end
			end
		end
	end
	return interactiveChoose(fn, fromHistory)
end

function lsFiles(option)
	local cpt
	if option=='-l' then	
		cpt=os.capture('git ls-files .', true)
	else
		if os.isWindows() then
			cpt=os.capture('git ls-files '..git_top(), true)
		else
			cpt=os.capture('git ls-files `git rev-parse --show-toplevel`', true)
		end
	end

	local files=string.lines(cpt)
	local files=array.sub(files,1,-2)
	table.sort(files, function(f1,f2)
		local _, count1 = string.gsub(f1, "/", "")
		local _, count2 = string.gsub(f2, "/", "")
		--local lf1, p2=os.processFileName(f1)
		--local lf2, p2=os.processFileName(f2)
		--return count1*1000+#lf1<count2*1000+#lf2
		return count1<count2
	end)
	return files
end
function choose(keys)
	local option
	if keys[1]=='-l' then
		option='-l'
		keys=table.isubset(keys,2)
	end
	local files=lsFiles(option)

	local fn={}
	for ifile, file in ipairs(files) do
		if string.isMatched(file,g_vimSrc)  then
			local filename=os.filename(file)
			for ikey,key in ipairs(keys) do
				if select(1,string.find(string.upper(filename), string.upper(key))) then
					fn[#fn+1]={file}
					break
				end
			end
		end
	end
	local chosen=interactiveChoose(fn)
	return chosen
end
-- main: 
if arg[1] then
	if arg[1]=="vi" then
		local keys=array.sub(arg,2)
		local chosen=choose(keys)
		if chosen then
			os.execute(g_vimpath..' "'..chosen[1]..'"')
		end
	elseif arg[1]=="gedit" then
		local keys=array.sub(arg,2)
		local chosen=choose(keys)
		if chosen then
			os.execute('gedit "'..chosen[1]..'"&')
		end
	elseif arg[1]=="gvim" then
		local keys=array.sub(arg,2)
		local chosen=choose(keys)
		if chosen then
			local function serverLaunched()
				local servers=string.tokenize(os.capture(g_vimpath..' --serverlist',true), "\n")
				local out=array.filter(function (x) return fn~="GVIM" end,servers)
				if #out==1 then
					return false
				end
				return true
			end

			if os.isWindows() then
				local chosenfile=os.toWindowsFileName(chosen[1])
				if not serverLaunched() then
					local cmd='start /b cmd /c "'..os.shellEscape(g_gvimpath..' "'..chosenfile..'"')..'"'
					print(cmd)
					-- launch gvim
					os.execute(cmd)
				else
					os.execute(g_gvimpath..' --remote-silent "'..chosenfile..'"')
				end
			else
				if not serverLaunched() then
					-- launch gvim
					os.execute(g_gvimpath..' -f&')
				end

				while(true) do
					if serverLaunched() then
						break
					end
				end

				os.execute(g_gvimpath..' --remote-silent "'..chosen[1]..'"')
			end
		end
	elseif arg[1]=="choose" then
		local keys=array.sub(arg,2)
		local chosen=choose(keys)
		if chosen then
			util.writeFile(g_cache_folder..'chosen', chosen[1] )
		end
	elseif arg[1]=="find" then
		local keys=array.sub(arg,2)
		local files=lsFiles()
		local fn={}
		for ifile, file in ipairs(files) do
			local passed=true
			for j=1,#keys do
				if not select(1,string.find(string.upper(file), string.upper(keys[j]))) then
					passed=false
				end
			end
			if passed then
				print(file)
			end
		end
	elseif arg[1]=="print" then
		local keys=array.sub(arg,2)
		local chosen=choose(keys)
		if chosen then
			os.execute('vim -c ":hardcopy" -c ":q" "'..chosen[1]..'"')
			os.execute('nautilus ~/PDF')
		end
	elseif arg[1]=='sync' then
		if arg[2]=='.' then
			local untracked=git_tools.getUntracked('.')
			local filter=function(files)
				local filtered={}
				for i,v in ipairs(files) do
					if select(1,string.find(v, '/')==nil) then
						table.insert(filtered, v)
					end
				end
				return filtered
			end
			local untracked_local=filter(untracked)
			if #untracked_local>0 then
				printTable(untracked_local)
				print("Do you want to add these untracked files to git repository? ([yes]/no)")
				ioread=io.read('*line')
				if string.lower(ioread)~='no' then
					for i,v in ipairs(untracked_local) do
						os.execute('git add "'..v..'"')
					end
					print(msg)
				end
			end
			local modified=filter(git_tools.getFilesToCommit('.'))
			if #modified>0 then
				printTable(modified)
				local bDone
				repeat
					bDone=true
					print("Do you want to commit these files to git repository? ([yes]/no/diff optionally followed by a commit message)")
					ioread=io.read('*line')
					if string.lower(string.sub(ioread, 1,2))=='no' then
					elseif string.lower(string.sub(ioread,1,1))=='d' then
						git_tools.execute('git diff .')
						bDone=false
					else
						local msg=string.sub(ioread,4)
						if msg=='' then
							msg='(no msg)'
						end
						for im, m in ipairs(modified) do
							git_tools.execute('git add "'..m..'"')
						end
						git_tools.execute('git commit -m "'..msg..'"')
					end
				until bDone 
			end
			print("------------------------")
			print("Pull:")
			print("------------------------")
			git_tools.pull(git_top())
			print("------------------------")
			print("Push:")
			print("------------------------")
			git_tools.push(git_top())
		else
			print("------------------------")
			print("Commit:")
			git_tools.commit(git_top())
			print("------------------------")
			print("Pull:")
			git_tools.pull(git_top())
			print("------------------------")
			print("Push:")
			git_tools.push(git_top())
		end
	elseif arg[1]=='pull' then
		git_tools.pull(git_top())
	elseif arg[1]=='push' then
		git_tools.push(git_top())
	elseif arg[1]=='commit' or arg[1]=='ci' then
		git_tools.commit(git_top())
	elseif arg[1]=='cif' then
		git_tools.commit(git_top(), true)
	elseif arg[1]=='fetch' then
		git_tools.fetch(git_top())
	elseif arg[1]=="etags" then
		local isSourceCode=function(str)
			return string.isMatched(str,g_etagsSrc)
		end

		local files=array.filter(isSourceCode,lsFiles())
		if arg[2]=='.' then
			files=array.filter(function (f) local s=string.find(f, '^%.%.') return not s end, files)
			--printTable(files)
		end
		util.writeFile(g_cache_folder..'gitvsrclist', table.concat(files,'\n'))
		local cmd='etags --extra=+f --langmap=c++:.inl.h.hpp.c.cpp.cc.cxx -L '..g_cache_folder..'gitvsrclist'
		print(cmd)
		os.execute(cmd)
	elseif arg[1]=='grep' then
		local files=lsFiles()
		if arg[2] then
			for i,f in ipairs(files) do
				if string.isMatched(f,g_grepSrc) then
					util.grepFile(f, arg[2])
				end
			end
		end
	elseif arg[1]=='ls' then
		local files=lsFiles()
		for i,f in ipairs(files) do print (f) end
	elseif arg[1]=='clear-hist' then
		os.execute('rm '..g_cache_folder..'cache_hist.txt')
	elseif arg[1]=='cmd' then
		local cmd={go=os.openFolder} 
		local fn=cmd[arg[2]]
		if arg[3] then fn(arg[3]) end
	elseif arg[1]=='diff' then

		local added=''
		if arg[2] then added=' '..arg[2] end
		if arg[3] then added=' "'..arg[3]..'"' end
		print('\n git diff --stat'..added)
		print('---------------------------------------------------')
		os.execute('git diff --stat'..added)
		print('\n\n-------------------git difftool:-------------------')
		os.execute('git difftool'..added)
	else
		printHelp()
	end
else
	printHelp()
end
